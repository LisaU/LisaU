<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[家乡三味]]></title>
    <url>%2F2018%2F08%2F18%2F%E5%AE%B6%E4%B9%A1%E4%B8%89%E5%91%B3%2F</url>
    <content type="text"><![CDATA[家乡好像真的没有什么特色的美食吧？ 我的家乡邓州不南不北，不西不东，寒暑分明，处于河南西南部南襄盆地中部偏西，岗多山少平原广，北接南阳宛城，南邻湖北襄阳。麦稻同食，以面食居多，可以有肥肉厚酒，也可以有粗茶淡饭。一个字普通，既不惊艳，也不薄凉。中规中矩，毫不出彩，就像这里的人一样平凡普通。 外地经常一提到邓州，想了好久，往往会说：“那儿呀，没什么没什么好吃的”。甚至有人说：“看你们吃面条，可以只需要一小碟蒜汁就可以吃一大碗白面条，怎么能吃的下去呀！”。这似乎更加做实了家乡无味道的传言。家乡味道，到底是什么呢？什么家乡味道才让别人觉得无味，而让你无论何时，无论何地，永远念念不忘，耿耿于怀呢？况且对于家乡邓州这种没甚么味道的中原地区呢？ ‘窝子面’是第一味，窝子面原为武汉热干面，是一种汉族传统名点。传入河南邓州后，经过改良，口味更上一层楼，加入了绿豆芽，牛肉丁，浇上牛油辣椒，香辣无比。邓州的窝子面，应该是从老河口传过来的，具体途径有待考证。在窝子面的基础上，更是发展出来，“牛杂面”，具体为，窝子面上要浇上卤过的牛肠等。具体为什么叫‘窝子面’还不可得知，卖窝子面的地方往往是一家不太高大上的偏僻路边小饭店，装修的破烂，当门一个铁皮灶台，中间是香葱、牛杂、辣椒等佐料，左边一口涮锅，右边是热气蒸腾的牛骨汤。前面铁皮柜上写着——窝子面（小），4块。牛杂面，6块。里里外外几张餐桌，上放蒜，醋，筷。外地的孩子在外面求学，打工飘荡一年后，总会想着在某个早晨，去这家店里坐着吃一碗少辣加芝麻酱的窝子面。套用我侄女的话，那就是心心念念的一个回家仪式。好像如果回家不去吃完窝子面，那便不算回家。不算对家乡完成一种使命感的神圣朝拜一样。 ‘胡辣汤’是第二味，胡辣汤，又名糊辣汤，源于河南北舞渡胡辣汤和河南周口市西华县逍遥镇的“逍遥镇胡辣汤”，是一种汤类小吃。两者的区别在于，北舞渡胡辣汤以回族羊肉汤为基础，加入面筋、粉条、葱花演变而来，而逍遥胡辣汤配有黑木耳、黄花菜等配菜，据历史考证来说，胡辣汤还是逍遥镇的更为正宗。胡辣汤的特点是汤味浓郁、汤色靓丽、汤汁粘稠，香辣可口，十分适合配合搭配油条、包子等其它早点，绝配为葱油饼。可与豆腐脑约1:1混合，称为“两掺”，降低了麻辣程度，也很受欢迎。由三十余种天然中草药按比例配制的汤料在加入胡椒和辣椒又用骨头汤做底料的胡辣汤又香又辣。胡辣汤，莫不是有种魔力，胡乱的辣就能征服所有的家乡游子，成为外地找了又找的早餐。 ‘卤面条’，卤面条也称蒸面条（部分地区称之为豆角焖面）。是传统面食，只要是中国人基本都吃过这种特色面条。可谓是肉、菜、面三合一具有很好口感的面条。记忆中最深的的美好就是老爸做的蒸面条，劲道的面条上浸染五花肉的油脂，吃一口就仿佛回到当年昏暗厨房里，烧着柴火，就着白炽灯一家人吃饭的时光。 这些味道往往很普通，很简单。完全没有亮丽的配色，惊艳的造型，浓烈的气味。她不同于重庆的火锅，和田的手抓肉，北京的烤鸭，广州的早点，往往一说到火锅便想到了重庆，一提及烤鸭便想到了北京。她完全不带有多余的色彩，也绝对不会让人觉得太多意外，她就是简单的食谱，平凡的身形，对于旁人无所挂念，对于家乡人心心念念。 不同的地方，不同的味道，不同的人，总有属于自己的一道或者几道家乡味道吧！总有可以对他人兴高采烈地诉说的家乡味道！总有对于在外地不停寻找逢人便说的一种味道！所以人们用五味杂陈形容人生，是因为懂得味道是每个人心中固守的乡愁。这种对于家乡味道的依恋就算是最后半个味道吧！因为这种味道永远不会终结，永远会有残缺。因为这种味道包含了家短里长，浸润了亲情友情。 戊戌年正月初四 2018-2-19 春节 于老家 晴]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活态度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类和接口的区别，以及abstract、interface、static、final、super、public、private、protect、default关键词的区别]]></title>
    <url>%2F2018%2F04%2F10%2F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[抽象类：A:抽象类和抽象方法必须用abstract关键字修饰 B:抽象类中不一定有抽象方法,但是有抽象方法的类必须定义为抽象类 C:抽象类不能实例化因为它不是具体的。抽象类有构造方法，但是不能实例化?构造方法的作用是什么呢?用于子类访问父类数据的初始化 D:抽象的子类a:如果不想重写抽象方法，该子类是一个抽象类。b:重写所有的抽象方法，这个时候子类是一个具体的类。 //abstract class Animal //抽象类的声明格式 abstract class Animal { //抽象方法 //public abstract void eat(){} //空方法体,这个会报错。**抽象方法不能有主体** public abstract void eat(); public Animal(){} } 抽象类的成员特点： 成员变量：既可以是变量，也可以是常量。 构造方法：有。 用于子类访问父类数据的初始化。 成员方法：既可以是抽象的，也可以是非抽象的。 抽象类的成员方法特性： A:抽象方法 强制要求子类做的事情。 B:非抽象方法 子类继承的事情，提高代码复用性。 abstract不能和哪些关键字共存? private 冲突 final 冲突 static 无意义 接口Interface 接口中的成员变量默认都是public、static、final类型的，必须被显式初始化 接口中的方法默认都是public、abstract类型的。 接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。 接口没有构造方法，不能被实例化，在接口中定义构造方法是非法的。 一个接口不能实现另一个接口，但它可以继承多个其他接口。interface C extends A, B{} // A和B都是接口 当类实现某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。 接口中没有方法体 访问控制修饰符四种访问级别：public、protected、默认、private private只能在同一个类中访问默认，只能在同一个类，同一个包中访问 protected，可以在统一各类，同一个包，子类(子类可以不在同一个包中)访问 public，不限制访问 类可用修饰符： abstract、public、final构造方法：public、protected、private局部变量：仅仅final abstract修饰符 抽象类中可以没有抽象方法，但包含了抽象方法的类必须被定义为抽象类。 没有抽象构造方法，没有抽象静态方法。 static 和 abstract不能连用 抽象类中可以有非抽象的构造方法，创建子类的实例时可能会调用这些构造方法。 抽象类及抽象方法不能被final修饰符修饰。final和abstract 不能连用，同样private和abstract不能连用。 抽象类不能被实例化。因为抽象类可能含有没有方法体的抽象方法 final修饰符final具有;不可改变的;含义，它可以修饰非抽象类，非抽象成员方法和变量 用final修饰的类不能被继承，没有子类。 用final修饰的方法不能被子类的方法覆盖。 用final修饰的变量表示常量，只能被赋一次值，必须被显式初始化。 private修饰的方法默认为是final方法，因而不能被子类的方法覆盖。 static修饰符 静态变量在内存中只有一个拷贝，在类的所有实例中共享。 在静态方法中不能直接访问实例方法和实例变量。 在静态方法中不能使用this和super关键字。 静态方法不能被abstract修饰 静态方法和静态变量都可以通过类名直接被访问。 当类被加载时，静态代码块只被执行一次。类中不同的静态代码块按它们在类中出现的顺序被依次执行public static void main(String args[]) {} 程序入口方法，可以被final修饰。 super关键字 在类的构造方法中，通过super语句调用这个类的父类的构造方法。在构造方法中，super语句必须作为构造方法的第一条语句。 在子类中访问父类的被屏蔽的方法和属性 只能在构造方法或实例方法内使用super关键字。 super关键字与类的特定实例相关方法覆盖（方法重写） 方法的参数签名和返回值类型必须相同，访问控制修饰符可以不同，但是子类方法不能缩小父类方法的访问权限。 子类方法抛出的异常必须和父类方法抛出的异常相同，或者是父类方法抛出的异常类的子类。 父类的静态方法是不能被子类覆盖为非静态方法。父类的非静态方法不能被子类覆盖为静态方法。 子类可以定义与父类的静态方法同名的静态方法，以便在子类中隐藏父类的静态方法。区别：运行时，JVM把静态方法和所属的类绑定，而把实例方法和所属的实例绑定。 父类的私有方法不能被覆盖 父类的非抽象方法可以被覆盖为抽象方法 方法重（chong）载 在一个类中不允许两个方法名相同，并且参数签名也完全相同的方法。 类的同一种功能，可能有多种实现，到底采用哪种实现方式，取决于调用者给定的参数。 对于类的方法（包括从父类中继承的方法），如果有两个方法的方法名相同，但参数不一致，那么可以说，一个方法是另一个方法的重载方法。 多态 对于一个引用类型的变量，Java编译器按照它声明的类型来处理。Base base = new Sub();base.subMethod(); // 编译出错，Base基类，Sub子类，编译器认为base是Base类型的引用变量，Base类没有subMethod()方法。这样子，就必须使用强制转换。(Sub)(base).subMethod(); 对于一个引用类型的变量，运行时JVM按照它实际引用的对象来处理。Base base = new Base();Sub sub = (Sub)base; // 编译通过，但是运行时抛出ClassCastException在运行时，子类的引用类型变量可以转换为父类的引用类型，而相反的过程却不可以。假定可以，即上边两行代码运行正常，那么sub.subMethod(); 执行时，JVM将找不到subMethod。sub实际引用的是Base类的实例。 在运行时环境中，通过引用类型变量来访问所引用对象的方法和属性时，JVM采用以下的绑定规则。①实例方法与引用变量实际引用的对象的方法绑定，即动态绑定。②静态方法与引用变量所声明的类型的方法绑定，即静态绑定。 编译阶段即绑定完成。③成员变量(静态变量和实例变量) 与引用类型所声明的类型的成员变量绑定。静态绑定]]></content>
      <categories>
        <category>Java基础技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>abstract</tag>
        <tag>interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java程序编译和运行过程]]></title>
    <url>%2F2018%2F04%2F08%2FJava%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java整个编译以及运行的过程相当繁琐，本文通过一个简单的程序来简单的说明整个流程。 如下图，Java程序从源文件创建到程序运行要经过两大步骤：1、源文件由编译器编译成字节码（ByteCode） 2、字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言（ “semi-interpreted” language） 图1、java程序编译运行过程 //MainApp.javapublic class MainApp { public static void main(String[] args) { Animal animal = new Animal(“Puppy”); animal.printName(); }}//Animal.javapublic class Animal { public String name; public Animal(String name) { this.name = name; } public void printName() { System.out.println(“Animal [“+name+”]”); }} 第一步(编译):创建完源文件之后，程序会先被编译为.class文件。Java编译一个类时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类，然后引用，否则直接引用，这个有点象make。如果java编译器在指定目录下找不到该类所其依赖的类的.class文件或者.java源文件的话，编译器话报“cant find symbol”的错误。 编译后的字节码文件格式主要分为两部分：常量池和方法字节码。常量池记录的是代码出现过的所有token(类名，成员变量名等等)以及符号引用（方法引用，成员变量引用等等）；方法字节码放的是类中各个方法的字节码。下面是MainApp.class通过反汇编的结果，我们可以清楚看到.class文件的结构： 图2、MainApp类常量池 图3、MainApp类方法字节码 第二步（运行）：java类运行的过程大概可分为两个过程：1、类的加载 2、类的执行。需要说明的是：JVM主要在程序第一次主动使用类的时候，才会去加载该类。也就是说，JVM并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。 下面是程序运行的详细步骤： 1、在编译好java程序得到MainApp.class文件后，在命令行上敲java AppMain。系统就会启动一个jvm进程，jvm进程从classpath路径中找到一个名为AppMain.class的二进制文件，将MainApp的类信息加载到运行时数据区的方法区内，这个过程叫做MainApp类的加载。2、然后JVM找到AppMain的主函数入口，开始执行main函数。3、main函数的第一条命令是Animal animal = new Animal(“Puppy”);就是让JVM创建一个Animal对象，但是这时候方法区中没有Animal类的信息，所以JVM马上加载Animal类，把Animal类的类型信息放到方法区中。4、加载完Animal类之后，Java虚拟机做的第一件事情就是在堆区中为一个新的Animal实例分配内存, 然后调用构造函数初始化Animal实例，这个Animal实例持有着指向方法区的Animal类的类型信息（其中包含有方法表，java动态绑定的底层实现）的引用。5、当使用animal.printName()的时候，JVM根据animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型信息的方法表，获得printName()函数的字节码的地址。6、开始运行printName()函数。 图4、java程序运行过程 特别说明：java类中所有public和protected的实例方法都采用动态绑定机制，所有私有方法、静态方法、构造器及初始化方法都是采用静态绑定机制。而使用动态绑定机制的时候会用到方法表，静态绑定时并不会用到。本文只是讲述java程序运行的大概过程，所以并没有细加区分。本文的所述的流程非常粗糙，想深入了解的读者请查阅其他资料。存在谬误的地方，请多指正。]]></content>
      <categories>
        <category>Java基础技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中static、fianl、static final之间的区别]]></title>
    <url>%2F2018%2F04%2F08%2FStatic%2F</url>
    <content type="text"><![CDATA[final：final可以修饰：属性，方法，类，局部变量（方法中的变量）。 final修饰的属性的初始化可以在编译期，也可以在运行期，初始化后不能被改变。 final修饰的属性跟具体对象有关，在运行期初始化的final属性，不同对象可以有不同的值。 final修饰的属性表明是一个常数（创建后不能被修改）。 final修饰的方法表示该方法在子类中不能被重写，final修饰的类表示该类不能被继承。 对于基本类型数据，final会将值变为一个常数（创建后不能被修改）；但是对于对象句柄（亦可称作引用或者指针），final会将句柄变为一个常数（进行声明时，必须将句柄初始化到一个具体的对象。而且不能再将句柄指向另一个对象。但是，对象的本身是可以修改的。这一限制也适用于数组，数组也属于对象，数组本身也是可以修改的。方法参数中的final句柄，意味着在该方法内部，我们不能改变参数句柄指向的实际东西，也就是说在方法内部不能给形参句柄再另外赋值）。 static：static可以修饰：属性，方法，代码段，内部类（静态内部类或嵌套内部类）。 static修饰的属性的初始化在编译期（类加载的时候），初始化后能改变。 static修饰的属性所有对象都只有一个值。 static修饰的属性强调它们只有一个。 static修饰的属性、方法、代码段跟该类的具体对象无关，不创建对象也能调用static修饰的属性、方法等 static和“this、super”势不两立，static跟具体对象无关，而this、super正好跟具体对象有关。 static不可以修饰局部变量。 static final和final static：static final和final static没什么区别，一般static写在前面。 static final： static修饰的属性强调它们只有一个，final修饰的属性表明是一个常数（创建后不能被修改）。static final修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问。 static final也可以修饰方法，表示该方法不能重写，可以在不new对象的情况下调用 总结：static：（静态修饰符）面向对象中static修饰的内容是隶属于类，而不是直接隶属于对象的，所以static修饰的成员变量一般称作类成员变量，而static修饰的方法一般称作类方法。 分类： 1、static变量，也叫作静态变量或者类变量。另一种是没有被static修饰的变量，叫实例变量。 2、static方法，也叫作静态方法或者类方法，静态方法中不能定义静态变量，实例方法也不能。 3、static代码块，静态块中，可以访问静态变量，调用静态方法。 注意事项： 1、static不依附于任何对象，就没有this方法。 2、static方法不可以调用非static方法，但非static方法可以调用static方法。 3、被static修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。 4、static方法不能被重写，当子类与父类中同时存在一样的static方法时，默认调用的是父类的静态方法，子类的静态方法就被隐藏了。 5、static块一般用于初始化类中的静态变量。在先执行static修饰的内容基础上，遵循先定义先执行的原则。 6、如果变量或方法经常被调用的话，就使用static修饰。否则少用，避免造成内存泄漏。 final：理解为不可变的。 注意事项： 1、final与static经常放在一起使用。 2、final修饰的变量，只能进行一次赋值操作。 3、final方法不能被重写，但可以被重载。 4、final类不能被继承。 5、final和abstract这两个关键字是相反的，不可能同时修饰类。因为final不能被重写，而abstract又必须重写。 6、final关键字不同于finally关键字，后者用于异常处理。 7、大多数情况下，并不用final来修饰方法和类，因为其可拓展性不好。 8、final在一定的环境下使用，可以提高程序的运行性能，优化程序的结构。 final变量与final类的代码例子： public final class Test{ final static int a=1; static { a=10; //报错，只能进行一次赋值操作 } } class FinalSon extends Test{ //报错，final类不能被继承 } final方法的代码例子： public class Test{ final static int a=1; final void A(){ //final方法 System.out.println(a); } } class FinalTest extends Test{ void A(){ //报错，final方法不能被重写 System.out.println(&quot;err&quot;); } } final abstract class FinalErr{ //final和abstract不能同时存在 /*......*/ }]]></content>
      <categories>
        <category>Java基础技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>static</tag>
        <tag>final</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你用Hexo+GitHub+Next创建你自己的博客1]]></title>
    <url>%2F2018%2F04%2F08%2FHexo0408%2F</url>
    <content type="text"><![CDATA[手把手教你 hexo + github搭建自己的博客以及个人主页。网上有很多这样的资料素材，但是没有一个系统化的教程,使你除了搜怎么搭建个人主页外，还要搜hexo使用教程,况且中间还可能遇到多种多样的坑。本篇文章，告诉你怎么使用github提供的空间，以及搭建自己的博客本人亲身检测，绿色无公害； 一、 环境安装1、 安装Git；下载地址GitHub是基于git实现的代码托管。git可能是目前最好用的版本控制系统了，非常受欢迎。GitHub可以免费使用，并且快速稳定。Github上面的世界很精彩，用久了你的眼界会开阔很多。 2、 安装Node.js 下载地址3、 安装Hexo利用 npm 命令即可安装。（在任意位置点击鼠标右键，选择Git bash）；输入： npm install hexo-cli -g npm install hexo-deployer-git --save 第一句是安装hexo，第二句是安装hexo部署到git page的deployer，两个都需要安装。 如下图即安装完成。 二、 初始化Hexo项目1、 创建hexo文件夹安装完成后，在你喜爱的文件夹下（如H:\hexo）， 执行以下指令(在H:\hexo内点击鼠标右键，选择Git bash)， Hexo 即会自动在目标文件夹建立网站所需要的所有文件。 hexo init hexo -v，检查hexo是否安装成功安装 Hexo 完成后，Hexo 将会在指定文件夹中新建所需要的文件。Hexo文件夹下的目录如下： 本地查看效果执行下面语句，执行完即可登录localhost:4000查看效果 hexo generate hexo server 登录localhost:4000，即可看到本地的效果如下： 二、 Github创建仓库Github是趋势，做it的人应今早融入这个大环境！ Github注册后： 1、 新建一个仓库yourusername.github.io 以后就是你的域名了。 2、 建好后进入你的仓库，点击settings 找到GitHub Pages栏目，点击选择一个主题：选择主题：主题生效后，我们的github pages也就设置完毕了，然后你现在在地址栏访问yourusername.github.io就可以测试刚才建好的站点。 3、 将博客部署到Github Pages上配置SSH密钥 配置Github的SSH密钥可以让本地git项目与远程的github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步。操作如下： 第一步、看看是否存在SSH密钥(keys)首先，我们需要看看是否看看本机是否存在SSH keys,打开Git Bash,并运行: $ cd ~/. ssh 检查你本机用户home目录下是否存在.ssh目录 如果，不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。 第二步、创建一对新的SSH密钥(keys)$ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 这将按照你提供的邮箱地址，创建一对密钥 Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如/c/Users/you/.ssh/github_rsa` 接着，根据提示，你需要输入密码和确认密码（说到这里，如果你很放心，其实可以不用密码，就是到输密码的地方，都直接回车，所以每次push就只管回车就行了。所谓的最安全的密码，就是没有密码 哈哈）。相关提示如下： Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again] 输入完成之后，屏幕会显示如下信息： Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 第三步、在GitHub账户中添加你的公钥运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。 clip &lt; ~/.ssh/id_rsa.pub 接着： 登陆GitHub,进入你的Account Settings. 2.选择SSH Keys 3.粘贴密钥，添加即可 第四步、测试可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改： $ ssh -T git@github.com 如果是下面的反馈： The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 不要紧张，输入yes就好，然后会看到： 第五步、设置用户信息现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。 Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字根据自己的喜好自己取，而不是GitHub的昵称。 $ git config --global user.name &quot;ryanlijianchang&quot;//用户名 $ git config --global user.email &quot;liji.anchang@163.com&quot;//填写自己的邮箱 第六步、SSH Key配置成功本机已成功连接到github。 4、 将本地的Hexo文件更新到Github的库中第一步、登录Github打开自己的项目 username.github.io 第二步、打开之后，点击SSH，选择SSH类型地址 第三步、复制地址 第四步、打开你一开始创建的Hexo文件夹（如F:\Blog\Hexo），用记事本打开刚文件夹下的_config.yml文件 第五步、在配置文件里作如下修改，保存 第六步、在Hexo文件夹下执行：hexo g hexo d 或者直接执行 hexo g -d 执行完之后会让你输入github的账号和密码，输入完后就可以登录我们自己的部署在Github Pages服务器上的博客了。对应的地址是 username.github.io(我的是：ryanlijianchang.github.io)。 假如这时候，报错 ERROR Deployer not found: git，那么就是你的deployer没有安装成功，你需要执行如下命令再安装一次： npm install hexo-deployer-git --save 这样，你再执行hexo g -d，你的博客就部署到Github上了。]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中数组、ArrayList、List、LinkedList、Vector之间的区别]]></title>
    <url>%2F2018%2F04%2F08%2FJava%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[1、数组长度固定、不能扩充List未限定长度，List是接口，ArrayList、LinkedList、Vector是实现它的具体类。 java中数组转list使用Arrays.asList(T… a)方法。 public class App { public static void main(String[] args) { List&lt;String&gt; stringA = Arrays.asList(&quot;hello&quot;, &quot;world&quot;,&quot;A&quot;); String[] stringArray = {&quot;hello&quot;,&quot;world&quot;,&quot;B&quot;}; List&lt;String&gt; stringB = Arrays.asList(stringArray); System.out.println(stringA); System.out.println(stringB); } } 这个方法使用起来非常方便，简单易懂。但是需要注意以下两点。 一、不能把基本数据类型转化为列表 仔细观察可以发现asList接受的参数是一个泛型的变长参数，而基本数据类型是无法泛型化的，如下所示： public class App { public static void main(String[] args) { int[] intarray = {1, 2, 3, 4, 5}; //List&lt;Integer&gt; list = Arrays.asList(intarray); 编译通不过 List&lt;int[]&gt; list = Arrays.asList(intarray); System.out.println(list); } } output： [[I@66d3c617] 这是因为把int类型的数组当参数了，所以转换后的列表就只包含一个int[]元素。 解决方案： 要想把基本数据类型的数组转化为其包装类型的list，可以使用guava类库的工具方法，示例如下： int[] intArray = {1, 2, 3, 4}; List&lt;Integer&gt; list = Ints.asList(intArray); 二、asList方法返回的是数组的一个视图 视图意味着，对这个list的操作都会反映在原数组上，而且这个list是定长的，不支持add、remove等改变长度的方法。 public class App { public static void main(String[] args) { int[] intArray = {1, 2, 3, 4}; List&lt;Integer&gt; list = Ints.asList(intArray); list.set(0, 100); System.out.println(Arrays.toString(intArray)); list.add(5); list.remove(0); } } output： [100, 2, 3, 4] UnsupportedOperationException UnsupportedOperationException List转Array集合转数组的toArray()和toArray(T[] a)方法 String[] array =new String[list.size()]; list.toArray(array); 采用set去重复数据，和set转array 1、集合转数组用方法，比如：list.toArray(new String[list.size()])； 2、利用set去除list里面重复的数据 Set&lt;String&gt; set = new HashSet&lt;String&gt;(); for(int i=0; i &lt; object.size(); i++){ set.add(object.get(i).toString()); } set.toArray(new String[set.size()]); 2、ArrayList和LinkedList的大致区别如下:1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 显然我们可以看出ArrayList更适合读取数据，linkedList更多的时候添加或删除数据。ArrayList内部是使用可増长数组实现的，所以是用get和set方法是花费常数时间的，但是如果插入元素和删除元素，除非插入和删除的位置都在表末尾，否则代码开销会很大，因为里面需要数组的移动。LinkedList是使用双链表实现的，所以get会非常消耗资源，除非位置离头部很近。但是插入和删除元素花费常数时间。 3、ArrayList和Vector的区别一.同步性: Vector是线程安全的，也就是说是同步的，而ArrayList是线程序不安全的，不是同步的。 二.操作: 由于Vector支持多线程操作，所以在性能上就比不上ArrayList了。 三.数据增长: ArrayList和Vector都有一个初始的容量大小，当存储进去它们里面的元素个数超出容量的时候，就需要增加ArrayList和Vector的存储空间，每次增加存储空间的时候不是只增加一个存储单元，是增加多个存储单元。 Vector默认增加原来的一倍，ArrayList默认增加原来的0.5倍。 Vector可以由我们自己来设置增长的大小，ArrayList没有提供相关的方法。 创建了一个向量类的对象后，可以往其中随意插入不同类的对象，即不需顾及类型也不需预先选定向量的容量，并可以方便地进行查找。对于预先不知或者不愿预先定义数组大小，并且需要频繁地进行查找，插入，删除工作的情况。可以考虑使用向量类。 向量类提供了三种构造方法： public vector() public vector(int initialcapacity,int capacityIncrement) public vector(int initialcapacity) 总结：List：是一个有序的集合，可以包含重复的元素。提供了按索引访问的方式。它继承 Collection List有两个重要的实现类：ArrayList 和 LinkedList ArrayList：我们可以将其看作是能够自动增长容量的数组。 利用ArrayList的toArray()返回一个数组。Arrays.asList()返回一个列表。 1.ArrayList底层采用数组实现，当使用不带参数的构造方法生成ArrayList对象时，实际上会在底层生成一个长度为10的Object类型数组 2.如果增加的元素个数超过了10个，那么ArrayList底层会新生成一个数组，长度为原数组的1.5倍+1，然后将原数组的内容复制到新数组当中，并且后续增加的内容都会放到新数组当中。当新数组无法容纳增加的元素时，重复该过程。16 3.对于ArrayList元素的删除操作，需要将被删除元素的后续元素向前移动，代价比较高。 4.集合当中只能放置对象的引用，无法放置原生数据类型，我们需要使用原生数据类型的包装类才能加入到集合当中。 5.集合当中放置的都是Object类型，因此取出来的也是Object类型，那么必须要使用强制类型转换将其转换为真正的类型（放置进去的类型）]]></content>
      <categories>
        <category>Java基础技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你用Hexo+GitHub+Next创建你自己的博客3]]></title>
    <url>%2F2018%2F04%2F08%2FNH0408%2F</url>
    <content type="text"><![CDATA[经过前面两篇基础文章，接下来我们就可以深入的去了解详细的，更优化的技巧来美化我们的博客了。 一、环境准备 1.安装Git 下载地址：https://git-scm.com/downloads 2.安装Node.js 下载地址：https://nodejs.org/en/ 3.安装hexo 利用 npm 命令即可安装。（在任意位置点击鼠标右键，选择Git bash） npm install -g hexo hexo安装中问题： npm ERR! registry error parsing json 错误 可能需要设置npm代理,执行命令 npm config set registry http://registry.cnpmjs.org hexo:command not found 删除刚刚安装的npm目录，重新执行命令npm install -g hexo安装hexo， -g为全局安装 二、初始化hexo项目 1.创建hexo文件夹 安装完成后，在你喜爱的文件夹下（如H:\hexo）， 执行以下指令(在H:\hexo内点击鼠标右键，选择Git bash)， Hexo 即会自动在目标文件夹建立网站所需要的所有文件。 hexo init（初始化hexo项目） 2.安装依赖包 npm install（安装npm依赖包） 现在我们已经搭建起本地的hexo博客了 hexo命令行使用 常用命令： hexo help #查看帮助hexo init #初始化一个目录hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成网页，可以在 public 目录查看整个网站的文件hexo server #本地预览，’Ctrl+C’关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹 简写（常用）：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 3.本地预览 执行一下命令： hexo generate 生成网页 hexo server 本地预览 到浏览器输入localhost:4000可以看到（系统再带的博客页面）。 三、更换模板 可能系统自带的模板不满足你的需求，没关系hexo提供了很多模板供你选择 访问：https://hexo.io/themes/选择自己喜欢的模板吧！ 本人选择的模板是MiHo 主题地址 http://blog.minhow.com/2017/08/01/blog/installation-configuration/ 1、搭建自己喜欢的模板 1.1 安装主题 删除hexo自带的themes文件夹在hexo下clone MiHo 主题 $ git clone https://github.com/WongMinHo/hexo-theme-miho.git themes/miho MiHo 主题需要Hexo 3.0或以上版本，请先升级。 1.2 更新主题（提供技术支持） cd themes/miho git pull 1.3 依赖安装 生成站点文章静态数据，用于站内搜索。 npm install hexo-generator-json-content –save 1.4 配置主题 此处需要理解： 与themes文件同级的_config.yml文件是hexo的项目配置文件（以下定义为‘主配置’） 在themes/miho文件中的_config.yml文件是主题的配置文件（以下定义为‘主题配置’） 注：可以在_config.yml中定义变量在模板中&lt;%- config.userurl %&gt;引入 在主配置下找到theme属性将其定义为theme: miho即可 主配置文件属性注释： # Hexo Configuration ## Docs: http://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site #站点信息 title: #标题 subtitle: #副标题 description: #站点描述，给搜索引擎看的 author: #作者 email: #电子邮箱 language: zh-CN #语言 # URL #链接格式 url: #网址 root: / #根目录 permalink: :year/:month/:day/:title/ #文章的链接格式 tag_dir: tags #标签目录 archive_dir: archives #存档目录 category_dir: categories #分类目录 code_dir: downloads/code permalink_defaults: # Directory #目录 source_dir: source #源文件目录 public_dir: public #生成的网页文件目录 # Writing #写作 new_post_name: :title.md #新文章标题 default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿） titlecase: false #标题转换成大写 external_link: true #在新选项卡中打开连接 filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false highlight: #语法高亮 enable: true #是否启用 line_number: true #显示行号 tab_replace: # Category &amp; Tag #分类和标签 default_category: uncategorized #默认分类 category_map: tag_map: # Archives 2: 开启分页 1: 禁用分页 0: 全部禁用 archive: 2 category: 2 tag: 2 # Server #本地服务器 port: 4000 #端口号 server_ip: localhost #IP 地址 logger: false logger_format: dev # Date / Time format #日期时间格式 date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/ time_format: H:mm:ss # Pagination #分页 per_page: 10 #每页文章数，设置成 0 禁用分页 pagination_dir: page # Disqus #Disqus评论，替换为多说 disqus_shortname: # Extensions #拓展插件 theme: landscape-plus #主题 exclude_generator: plugins: #插件，例如生成 RSS 和站点地图的 - hexo-generator-feed - hexo-generator-sitemap # Deployment #部署，将 lmintlcx 改成用户名 deploy: type: git repo: github创库地址.git （需要使用ssh） branch: master 不要担心主题配置文件有中文注释，根据提示走就可以轻松搞定 注意：主配置文件中的 url ，root配置url: https://hjm100.github.io/Blogsroot: /Blogs 如果你想要通过https://hjm100.github.io去访问你的博客root: /因为我的https://hjm100.github.io用来装自己的主页，所以我的博客地址架构如上 虽然选择了自己想要的主题，但是主题中显示有关主体信息，以及博客信息，看着就不舒服 特别是网页底部版权那块，教你怎么改： 修改模板标签(用于一般模板不满足个人需求)步骤：用文本编辑器打开 Hexo 所在的目录打开 themes 目录打开你想要编辑的主题所在的目录中的 layout 目录打开 layout 目录下的 _partial 目录打开 _partial 目录下的 footer.ejs 文件修改底部链接post/copyright.ejs用于修改文章页脚用户链接 好了，至此，本地博客已经搭建起来了，只是本地哦，别人看不到的。下面，我们要部署到Github。 四、外网部署（为的就是省钱–哈哈）： github为我们提供了一个放置静态资源的空间，空间不大但是足以满足你博客以及个人主页的部署 如果有后台就不行了（不过可以选择自己租服务器，一个月就50多，不差钱的同鞋可以考虑一下） 以我的为例：github放置个人主页以及博客 1.申请账号，设置公钥这些老生常谈的话题就不用多说了（直接进入主题） 2.创建代码仓库2.1 点击加号穿件仓库New repository2.2仓库名字格式必须为: yourname.github.io （yourname为你的账号名）2.3进入新建的项目点击Settings设置项目找到GitHub Pages 点击change theme选择模板这时你的项目中就有了生成文件（但是这是系统创建的）2.4 不要删除_config.yml文件直接引入你的个人主页项目即可，默认打开index.html ok此时你的个人主页已经搭建好了 Blogs的搭建，你可以新建一个代码仓库（把这个代码仓库设置为html） 在设置中的GitHub Pages 选择Source 中的下拉框为master branch做法与上一样！ 3.仓库分析（yourname.github.io放个人主页，Blogs存放博客） 4.Blogs上传：将主配置中的deploy属性添加一下代码， deploy: type: git repo: 你github上的Blogs的SSH地址（注意ssh必须是系统最先生成的） branch: master 运行命令行 hexo g 编译文件 hexo d 提交文件即可 4.发布博文 在hexo\source_posts文件夹下新建一个MD文件类型的文档 或者命令行 hexo new 博文创建 --- title: 博文 （博文标题） date: 2017-09-27 14:49:15 （博文时间） categories: hexo #文章文类 tags: web开发技术 （ 文章标签） --- 这里正常写文章即可 # 可以理解为h1(但是#后面一定要有空格) 1$ console.log(&apos;Hello hjm100&apos;) //这里写代码 注意：博文写好之后一定要先在本地查看后在提交！！！！！！ 五、域名的配置（将github提供的二级域名与自己购买的域名绑定）： 1.可以前往腾讯购买一个域名，一般cn域名一年就20多块钱 2.点击 Github 上项目的 Settings，GitHub Pages， 提示Your site is published at http://hjm100.cn (这是我买的域名) Custom domain下面的对话框填写你的域名即可 将独立域名与GitHub Pages的空间绑定 方法一：在站点source目录下面，新建一个名为CNAME的文本文件， 里面写入你要绑定的域名，比如hjm100.cn 方法二：在Repository的根目录下面，新建一个名为CNAME的文本文件， 里面写入你要绑定的域名，比如hjm100.cn 在github上面添加好自己的域名后，不要着急，此时你的域名还没有与博客完全绑定 打开cmd命令行，使用ping hjm100.github.io 查看到git对应的ip地址 前往你购买域名的平台进行ipv4域名解析，输入你ping到的域名即可， 域名解析后，去浏览器访问一下你的域名吧！就是这么神奇！！ 至此你的博客已经搭建完毕了，不要感谢我，本人博客预览hjm100.github.io 域名https添加（让你的域名更加安全） 第一步首先注册一个属于自己的域名，可以选择cn域名，不贵一年就20多元我的域名是hjm100.cn 第二步域名https添加， 1.登录这个网站并注册：https://www.cloudflare.com/（直接使用邮箱注册） 2.注册完毕后登录，如果你之前没有用过，则系统会直接显示 Add a website对话框，再次填写hjm100.cn(你的域名)点击scan DNS Records即可， 系统会自动扫描你的域名（扫描需要等待一定时间） 3.扫描完毕后点击Continue(继续) 4.添加DNS Records typt:CNAME类型 name：www Value: 后续问题请自行百度谢谢！！！！！！ 附件小妙招： 怎么换一台电脑仍然可以使用hexo（亲测有用） 1.在Blogs这个项目中创建hexo分支用来储存开发环境（master分支用来存储生成的静态资源） git branch hexo（新建一个hexo分支） 2.将hexo分支发布在github上(这个时候分支中可能有master分支的文件) git push origin hexo(将代码提交到hexo分支上) 3.切换到hexo分支上（如果有文件就清空分支中的内容除了.git文件） git checkout hexo（切换到hexo分支上） 4.整理你的开发环境hexo,修改hexo下面的.gitignore(限制git上传)文件 bash db.json *.log node_modules/ public/ .deploy*/ 5.删除themes–&gt;miho文件中的 .git文件以及.gitignore 6.将你上述修改的hexo文件提交到hexo分支里面（不要改错奥）在hexo分之下即可 git add . git commit . git push origin hexo 7.当你换电脑的时候，配置公钥以及全局安装npm install -g hexo（请参考以上说明）下载的分支默认显示的是master分支，请切换到hexo分支，cd hexo（进入到hexo文件）执行npm install 安装node模块，按照以上写博客提交博客即可同步 8.切结，修改过hexo文件中的内容后记得提交hexo分支，以免你再次换电脑的时候使用]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你用Hexo+GitHub+Next创建你自己的博客2]]></title>
    <url>%2F2018%2F04%2F08%2FNext0408%2F</url>
    <content type="text"><![CDATA[NexT 拥有丰富而简单的配置,结合第三方服务,打造属于您自己的博客主题配置 NexT 坚持将复杂的细节隐藏,提供尽量少并且简便的设置,保持最大限度的易用性。 一、 选择Hexo主题进入Hexo的官网主题专栏挑选我们喜欢的主题 二、 克隆主题再打开Hexo文件夹下的themes目录（F:\Blog\hexo\themes），右键Git Bash，在命令行输入: git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) 下载中，等待下载完成： 三、 修改Hexo配置文件下载完成后，打开Hexo文件夹下的配置文件_config.yml 修改参数为：theme: hexo-theme-next 四、 部署完成后查看效果hexo d -g]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse项目中.classpath文件详解]]></title>
    <url>%2F2018%2F04%2F08%2F%E9%A1%B9%E7%9B%AE%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%981%2F</url>
    <content type="text"><![CDATA[1、前言在使用eclipse或者myeclipse进行java项目开发的时候，每个project（工程）下面都会有一个.classpath文件，那么这个文件究竟有什么作用？ 2、作用.classpath文件用于记录项目编译环境的所有信息，包括：源文件路径、编译后class文件存放路径、依赖的jar包路径、运行的容器信息、依赖的外部project等信息。如果把该文件删除，则eclipse不能讲该工程识别为一个正常的java工程，仅仅当做普通的文件夹而导致不能正常运行。 3、.classpath内容3.1 kind=”src” src：即source 源文件，代表的是一个源文件，path=”src”是一个相对路径，相对.classpath文件本身，即path=”src”表示文件夹src与.classpath在同一个目录，且代表源文件。 &lt;classpathentry kind=&quot;src&quot; path=&quot;src&quot;/&gt; &lt;classpathentry kind=&quot;src&quot; path=&quot;resource&quot;/&gt; kind=”src”的操作对应于“Java Build Path”的“Source”tab页 另外，当指定属性combineaccessrules=”false”是则代表引入外部project，具体如下： &lt;classpathentry combineaccessrules=&quot;false&quot; kind=&quot;src&quot; path=&quot;/mybatis&quot;/&gt; 对应页面tab，其中path=”/mybatis”，是相对应workspace下的绝对路径。 3.2 kind=”output” output用于指定java源文件编译后的class文件存放路径，格式如下： &lt;classpathentry kind=&quot;output&quot; path=&quot;WebContent/WEB-INF/classes&quot;/&gt; path：代表存放class文件路径，同样是相对.classpath文件的路径，找到“WebContent/WEB-INF/classes”，可以看到class文件的存放 假设修改输出文件路径，则相应内容也会改变改为：spring-mybatis\WebContent\WEB-INF\newclasses则.classpath文件内容修改为： 实际存放class文件的路径也会改变 3.3 kind=”con” con即是container,就是程序运行的容器，或者就说是运行环境也OK，它实际上是在Myeclipse最初的时候要配置installed JREs中指定（一般情况下我们指定的是JDK），但是这里实际使用的是JDK下的JRE中的jar包，就是JDK_HOME/jre/lib就是对应的这条语句。具体内容如下 3.4 kind=”lib” kind=”lib”用于指定project依赖的Referenced Libraries，如图增加了一个jar包 4、那么java项目中classpath具体是指哪的路径？只知道把配置文件如：mybatis.xml、spring-web.xml、applicationContext.xml等放到src目录（就是存放代码.java文件的目录），然后使用“classpath：xxx.xml”来读取，都放到src目录准没错，那么到底classpath到底指的什么位置呢？ src路径下的文件在编译后会放到WEB-INF/clases路径下吧。默认的classpath是在这里。直接放到WEB-INF下的话，是不在classpath下的。用ClassPathXmlApplicationContext当然获取不到。 如果单元测试的话，可以在启动或者运行的选项里指定classpath的路径的。 用maven构建项目时候resource目录就是默认的classpath classPath即为java文件编译之后的class文件的编译目录一般为web-inf/classes，src下的xml在编译时也会复制到classPath下 ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;xxxx.xml&quot;); //读取classPath下的spring.xml配置文件 ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;WebRoot/WEB-INF/xxxx.xml&quot;); //读取WEB-INF 下的spring.xml文件 5、Java中获取路径jsp中取得路径以工程名为TEST为例： (1)得到包含工程名的当前页面全路径：request.getRequestURI()结果：/TEST/test.jsp (2)得到工程名：request.getContextPath()结果：/TEST (3)得到当前页面所在目录下全名称：request.getServletPath()结果：如果页面在jsp目录下 /TEST/jsp/test.jsp (4)得到页面所在服务器的全路径：application.getRealPath(“页面.jsp”)结果：D:/resin/webapps/TEST/test.jsp (5)得到页面所在服务器的绝对路径：absPath=new java.io.File(application.getRealPath(request.getRequestURI())).getParent();结果：D:/resin/webapps/TEST 在类中取得路径(1)类的绝对路径：Class.class.getClass().getResource(“/“).getPath()结果：/D:/TEST/WebRoot/WEB-INF/classes/pack/ (2)得到工程的路径：System.getProperty(“user.dir”)结果：D:/TEST 在Servlet中取得路径(1)得到工程目录：request.getSession().getServletContext().getRealPath(“”) 参数可具体到包名。结果：E:/Tomcat/webapps/TEST (2)得到IE地址栏地址：request.getRequestURL()结果：http://localhost:8080/TEST/test (3)得到相对地址：request.getRequestURI()结果：/TEST/test]]></content>
      <categories>
        <category>Java基础技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用IO流操作详解]]></title>
    <url>%2F2018%2F04%2F08%2FJava%E5%B8%B8%E7%94%A8IO%E6%B5%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1.基本概念IO：Java对数据的操作是通过流的方式，IO流用来处理设备之间的数据传输，上传文件和下载文件，Java用于操作流的对象都在IO包中。 2.IO流的分类图示：（主要IO流） 3.字节流（1）.字节流基类 1）.InputStream InputStream：字节输入流基类，抽象类是表示字节输入流的所有类的超类。 常用方法： // 从输入流中读取数据的下一个字节 abstract int read() // 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b中 int read(byte[] b) // 将输入流中最多 len 个数据字节读入 byte 数组 int read(byte[] b, int off, int len) // 跳过和丢弃此输入流中数据的 n个字节 long skip(long n) // 关闭此输入流并释放与该流关联的所有系统资源 void close() 2）.OutputStream OutputStream：字节输出流基类，抽象类是表示输出字节流的所有类的超类。 常用方法： // 将 b.length 个字节从指定的 byte 数组写入此输出流 void write(byte[] b) // 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流 void write(byte[] b, int off, int len) // 将指定的字节写入此输出流 abstract void write(int b) // 关闭此输出流并释放与此流有关的所有系统资源 void close() // 刷新此输出流并强制写出所有缓冲的输出字节 void flush() （2）.字节文件操作流 1）.FileInputStream FileInputStream：字节文件输入流，从文件系统中的某个文件中获得输入字节，用于读取诸如图像数据之类的原始字节流。 构造方法： // 通过打开一个到实际文件的连接来创建一个FileInputStream，该文件通过文件系统中的File对象file指定 FileInputStream(File file) // 通过打开一个到实际文件的连接来创建一个FileInputStream，该文件通过文件系统中的路径name指定 FileInputStream(String name) 常用方法：覆盖和重写了父类的的常用方法。 // 读取f盘下该文件f://hell/test.txt //构造方法1 InputStream inputStream = new FileInputStream(new File(&quot;f://hello//test.txt&quot;)); int i = 0; //一次读取一个字节 while ((i = inputStream.read()) != -1) { // System.out.print(i + &quot; &quot;);// 65 66 67 68 //为什么会输出65 66 67 68？因为字符在底层存储的时候就是存储的数值。即字符对应的ASCII码。 System.out.print((char) i + &quot; &quot;);// A B C D } //关闭IO流 inputStream.close(); // 读取f盘下该文件f://hell/test.txt //构造方法2 InputStream inputStream2 = new FileInputStream(&quot;f://hello/test.txt&quot;); // 字节数组 byte[] b = new byte[2]; int i2 = 0; // 一次读取一个字节数组 while ((i2 = inputStream2.read(b)) != -1) { System.out.print(new String(b, 0, i2) + &quot; &quot;);// AB CD } //关闭IO流 inputStream2.close(); 注： 一次读取一个字节数组，提高了操作效率,IO流使用完毕一定要关闭。 2）.FileOutputStream FileOutputStream：字节文件输出流是用于将数据写入到File，从程序中写入到其他位置。 构造方法： // 创建一个向指定File对象表示的文件中写入数据的文件输出流 FileOutputStream(File file) // 创建一个向指定File对象表示的文件中写入数据的文件输出流 FileOutputStream(File file, boolean append) // 创建一个向具有指定名称的文件中写入数据的输出文件流 FileOutputStream(String name) // 创建一个向具有指定name的文件中写入数据的输出文件流 FileOutputStream(String name, boolean append) 常用方法：覆盖和重写了父类的的常用方法。 OutputStream outputStream = new FileOutputStream(new File(&quot;test.txt&quot;)); // 写出数据 outputStream.write(&quot;ABCD&quot;.getBytes()); // 关闭IO流 outputStream.close(); // 内容追加写入 OutputStream outputStream2 = new FileOutputStream(&quot;test.txt&quot;, true); // 输出换行符 outputStream2.write(&quot;\r\n&quot;.getBytes()); // 输出追加内容 outputStream2.write(&quot;hello&quot;.getBytes()); // 关闭IO流 outputStream2.close(); 注；输出的目的地文件不存在，则会自动创建，不指定盘符的话，默认创建在项目目录下;输出换行符时一定要写\r\n不能只写\n,因为不同文本编辑器对换行符的识别存在差异性。 （3）.字节缓冲流（高效流） 1）.BufferedInputStream BufferedInputStream：字节缓冲输入流，提高了读取效率。 构造方法： // 创建一个 BufferedInputStream并保存其参数，即输入流in，以便将来使用。 BufferedInputStream(InputStream in) // 创建具有指定缓冲区大小的 BufferedInputStream并保存其参数，即输入流in以便将来使用 BufferedInputStream(InputStream in, int size) InputStream in = new FileInputStream(&quot;test.txt&quot;); // 字节缓存流 BufferedInputStream bis = new BufferedInputStream(in); byte[] bs = new byte[20]; int len = 0; while ((len = bis.read(bs)) != -1) { System.out.print(new String(bs, 0, len)); // ABCD // hello } // 关闭流 bis.close(); 2）.BufferedOutputStream BufferedOutputStream：字节缓冲输出流，提高了写出效率。 构造方法： // 创建一个新的缓冲输出流，以将数据写入指定的底层输出流 BufferedOutputStream(OutputStream out) // 创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流 BufferedOutputStream(OutputStream out, int size) 常用方法： // 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此缓冲的输出流 void write(byte[] b, int off, int len) // 将指定的字节写入此缓冲的输出流 void write(int b) // 刷新此缓冲的输出流 void flush() BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;test.txt&quot;, true)); // 输出换行符 bos.write(&quot;\r\n&quot;.getBytes()); // 输出内容 bos.write(&quot;Hello Android&quot;.getBytes()); // 刷新此缓冲的输出流 bos.flush(); // 关闭流 bos.close(); 4.字符流（1）.字符流基类 1）.Reader Reader:读取字符流的抽象类. 常用方法： // 读取单个字符 int read() // 将字符读入数组 int read(char[] cbuf) // 将字符读入数组的某一部分 abstract int read(char[] cbuf, int off, int len) // 跳过字符 long skip(long n) // 关闭该流并释放与之关联的所有资源 abstract void close() 2）.Writer Writer:写入字符流的抽象类. 常用方法： // 写入字符数组 void write(char[] cbuf) // 写入字符数组的某一部分 abstract void write(char[] cbuf, int off, int len) // 写入单个字符 void write(int c) // 写入字符串 void write(String str) // 写入字符串的某一部分 void write(String str, int off, int len) // 将指定字符添加到此 writer Writer append(char c) // 将指定字符序列添加到此 writer Writer append(CharSequence csq) // 将指定字符序列的子序列添加到此 writer.Appendable Writer append(CharSequence csq, int start, int end) // 关闭此流，但要先刷新它 abstract void close() // 刷新该流的缓冲 abstract void flush() （2）.字符转换流 1）.InputStreamReader InputStreamReader：字节流转字符流，它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。 构造方法： // 创建一个使用默认字符集的 InputStreamReader InputStreamReader(InputStream in) // 创建使用给定字符集的 InputStreamReader InputStreamReader(InputStream in, Charset cs) // 创建使用给定字符集解码器的 InputStreamReader InputStreamReader(InputStream in, CharsetDecoder dec) // 创建使用指定字符集的 InputStreamReader InputStreamReader(InputStream in, String charsetName) 特有方法： //返回此流使用的字符编码的名称 String getEncoding() //使用默认编码 InputStreamReader reader = new InputStreamReader(new FileInputStream(&quot;test.txt&quot;)); int len; while ((len = reader.read()) != -1) { System.out.print((char) len);//爱生活，爱Android } reader.close(); //指定编码 InputStreamReader reader = new InputStreamReader(new FileInputStream(&quot;test.txt&quot;),&quot;utf-8&quot;); int len; while ((len = reader.read()) != -1) { System.out.print((char) len);//????????Android } reader.close(); 注：Eclipse默认使用GBK编码,test.txt文件所以是GBK编码，当指定utf-8编码时所以会乱码。 2）.OutputStreamWriter OutputStreamWriter：字节流转字符流。 构造方法： // 创建使用默认字符编码的 OutputStreamWriter OutputStreamWriter(OutputStream out) // 创建使用给定字符集的 OutputStreamWriter OutputStreamWriter(OutputStream out, Charset cs) // 创建使用给定字符集编码器的 OutputStreamWriter OutputStreamWriter(OutputStream out, CharsetEncoder enc) // 创建使用指定字符集的 OutputStreamWriter OutputStreamWriter(OutputStream out, String charsetName) 特有方法： //返回此流使用的字符编码的名称 String getEncoding() （3）.字符缓冲流（高效流） 1）.BufferedReader BufferedReader：字符缓冲流，从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 构造方法： // 创建一个使用默认大小输入缓冲区的缓冲字符输入流 BufferedReader(Reader in) // 创建一个使用指定大小输入缓冲区的缓冲字符输入流 BufferedReader(Reader in, int sz) 特有方法： // 读取一个文本行 String readLine() //生成字符缓冲流对象 BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;test.txt&quot;))); String str; //一次性读取一行 while ((str = reader.readLine()) != null) { System.out.println(str);// 爱生活，爱Android } //关闭流 reader.close(); 2）.BufferedWriter BufferedWriter：字符缓冲流，将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。 构造方法： // 创建一个使用默认大小输出缓冲区的缓冲字符输出流 BufferedWriter(Writer out) // 创建一个使用给定大小输出缓冲区的新缓冲字符输出流 BufferedWriter(Writer out, int sz) 特有方法： // 写入一个行分隔符 void newLine() （4）.FileReader、FileWriter FileReader：InputStreamReader类的直接子类，用来读取字符文件的便捷类，使用默认字符编码。 FileWriter：OutputStreamWriter类的直接子类，用来写入字符文件的便捷类，使用默认字符编码。 5.高效流效率比对读取f盘下的一个视频文件到项目中：文件大小29.5 MB 读取方式一： FileInputStream inputStream = new FileInputStream(&quot;f://滑板//HEEL_FLIP.mp4&quot;); FileOutputStream outputStream = new FileOutputStream(&quot;HEEL_FLIP.mp4&quot;); int len; // 开始时间 long begin = System.currentTimeMillis(); // 一次读取一个字节 while ((len = inputStream.read()) != -1) { outputStream.write(len); } // 用时毫秒 System.out.println(System.currentTimeMillis() - begin);// 213195 //关闭流释放资源 inputStream.close(); outputStream.close(); 读取方式二： FileInputStream inputStream = new FileInputStream(&quot;f://滑板//HEEL_FLIP.mp4&quot;); FileOutputStream outputStream = new FileOutputStream(&quot;HEEL_FLIP.mp4&quot;); int len; byte[] bs = new byte[1024]; // 开始时间 long begin = System.currentTimeMillis(); // 一次读取一个字节数组 while ((len = inputStream.read(bs)) != -1) { outputStream.write(bs, 0, len); } // 用时毫秒 System.out.println(System.currentTimeMillis() - begin);// 281 inputStream.close(); outputStream.close(); 读取方式三： FileInputStream inputStream = new FileInputStream(&quot;f://滑板//HEEL_FLIP.mp4&quot;); BufferedInputStream bis = new BufferedInputStream(inputStream); FileOutputStream outputStream = new FileOutputStream(&quot;HEEL_FLIP.mp4&quot;); BufferedOutputStream bos = new BufferedOutputStream(outputStream); int len; byte[] bs = new byte[1024]; // 开始时间 long begin = System.currentTimeMillis(); while ((len = bis.read(bs)) != -1) { bos.write(bs, 0, len); } // 用时毫秒 System.out.println(System.currentTimeMillis() - begin);// 78 bis.close(); bos.close();]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java IO流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北国的雨]]></title>
    <url>%2F2016%2F08%2F19%2F%E5%8C%97%E5%9B%BD%E7%9A%84%E9%9B%A8%2F</url>
    <content type="text"><![CDATA[北国的雨，似乎有种魔力。她的身影细细碎碎，她的声音懵懵懂懂，她总让你有种不想去上班、上课的冲动。你懒懒的，而她却很欢快，滴滴嗒嗒地落在地上，然后又轻灵的跳起来，在水面上散成一朵朵的白荷花，随风钻入你的裤脚，挠你的痒，扰你的心。还让你的路泥泞，让你的地铁晚点，但是呢！你绝不会因为这个而恼她，因为她是你的五彩斑斓啊！春雨温柔，夏雨欢快，秋雨萧瑟，冬雨冷凛，春夏秋冬，柳莲枫梅，她是你平凡的生活的一抹亮色，也给你静静思考的勇气。 北京的雨，已经很有味道了。但总觉得不够，是觉得雨敲打在钢筋混凝土上声音不够轻灵吗？还是觉得若是没有一点点鸟飞虫鸣相伴不够有生气吗？抑或是觉得若是没有几株细草小花点缀不够诗意呢？似乎没有明确答案，但我还是喜欢老家的雨多些！是因为北京的雨不喜欢像我这样一枚头发蓬乱、眼光呆滞、胸无大志的屌丝吗？似乎缺少了点生活的生气啊！要不然，每次搭乘滴滴和司机闲聊时，他总是一语道破：“你们是搞IT的吧！”。十个有八个可以猜到，我去，难道我们脑门上写了“程序猿”三个字吗？从这个原因看，好像我和北京的雨很不搭呢！ 是因为北京的雨有些孤单吗？她从天上来，本希望有青山绿水相伴：“风过镜湖起渏涟，雨落青山生云烟”，可以有荷花秋菊相伴：“一塘夜雨敲荷韵，几壑秋风探菊踪”，也可以有窗棂春风相伴“雨落敲窗，且听风吟”，而现在，没有流水落花，也没有水润清尘，只能落入下水道，随着污秽无语凝噎了。雨落在身上，她的孤单凉意好像我也有了，茫茫然的人群，匆匆地在我身旁走过，淹没在夜色里，再无交集。北京的雨是孤单了啊！雨好像小了点，天色也黑了点，遥想老家的雨也染了墨吧！没有高楼大厦、霓虹灯光的遮掩，她才显得更加纯粹，更有味道。那些繁密的树木，那些莽莽杂草，还有远方的天空和脚下的蛐蛐，和雨一起被染成的一样颜色。脚踩在泥泞上，啧啧作响，也像诗一样有了平平仄仄的韵味。偶尔，有几滴雨落在眼里，再去瞧瞧远方的田地，苞谷幼苗满满延伸出去，在广阔无际的田里氤氲起雾气。那种感觉好像苏轼在大江上，醉眼朦胧，心生辽阔之意，熏熏然醉在其中。 要是冬天啊！她也不会如北京的雨一样夹杂着粗砺风沙，也不会像江南的雨那样浸润着花香，更不会像广州的雨那样磅礴粗暴。她只是雨，也许带着些干冷，也许也带着些寒风，但她绝不容许砂子和青苔的沾染。她只是简简单单，枝杈分明，天宽地广。她是中和了北国和南国的特点啊！从广州到北京，从南方的磅礴大雨到北国少了一点味道的雨，总有一些飘忽不定的感觉。悠悠荡荡，无处落脚，不禁心生杂念。不免有些失落，好像被一种叫做浮躁的牢，紧紧束缚，无法呼吸。下雨天，总是能让人静静的。 预报说明天是晴天，也有可能气象局的程序猿正在昏昏沉沉的敲代码，从而更新错了天气。就算是那样，又有什么关系呢！ 于北京]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活态度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行于路上2]]></title>
    <url>%2F2015%2F08%2F18%2F%E8%A1%8C%E4%BA%8E%E8%B7%AF%E4%B8%8A2%2F</url>
    <content type="text"><![CDATA[天昏沉地睡着了。薄薄的雾气遮掩着她的脸庞，偶尔滴下几滴泪水。是她感觉夏天过去，秋天来了的悲伤吗？亦或是年纪大了的癔症？在这样的氛围里坐上火车回家，跟随着窗外像静物画一样的风景入睡。耳朵里纷杂的噪声也像在睡梦中的梦呓。轰隆隆的火车呼啸而过的也是我的青春年少。钱钟书《围城》里说“爱情是一个围城”。我却想说“时间也是个围城，正呆在里面的人，感觉时间很慢，急切地想过完。可回忆过去，却又恨不得吃一万颗后悔药，想重返十八岁。”记得大学来的时候是上午，阳光灿烂。看着外面的一马平川，恨不得也像杜甫一样站在山顶，大声喊着“会当凌绝顶，一览众山小。”也记得当初看着图书馆，对赵小爽发短信说“立志横扫图书馆”，现在看来，只能一声哭笑，呵呵。曾经满怀憧憬的说“愿岁月静好，永远不变。”可岁月是把毒饲料，不仅把我变成了小胖子，也把我变成了一个曾经最讨厌的自己。原来我这样啊！以前学习超刻苦，感觉不会玩游戏，不会放纵自己，时刻以清新脱俗文艺男自居，偶尔发个说说，写一点狗屁不通的日志。过节我会很细心地一个个写短信问候，完全手工，完全清新，尽管他们说我骚情。晚上，我会给一个朋友说晚安。假期我也会和一个女生聊一些无聊琐事。我也会很骚的去和张风雨一起骑单车唱老男孩，然后更骚情的去火车轨道上吹呼啸而过的风。我也会很装的在窗户边看个闲书，偶尔看一下过路的美眉。我也会给所有的朋友打个电话，尽管不知道说啥，尽管我其实是个喜欢安静的人，我也会和他们聊聊。我也会对每一个女生好，很细心的发一个短信或者微笑。当然，我也会写一个下雨天或者下雪天，愉悦的或者悲伤的说说，尽管当初刘帅说我很骚逼。原来当初我的日子是如此多彩啊！是那么特立独行啊！而现在我会很长时间的打游戏；我会长达几年不给朋友打个电话，然后慢慢失联，慢慢相忘于天涯；我会窝在宿舍里自己发着呆从早上到晚上；我也会感觉做什么都感觉无聊，日子就只剩下睡吃睡。我不会在节日的时候发短信，也不会在空间里肆意污染，更不会说去外边走走停停。所以现在感觉很疲倦，虽然知道这种日子仍将继续。可能在火车上犯了困，也可能很久没写了，所以说了好多废话。我想我会慢慢找回自己，尽管我知道这有多难。现在不听你们说我骚情，反而感觉很不适应了。感觉自己丢了，走在冷风中的岔路口里，不知方向。今年二十三了，我选择二战，不知道是对是错，也没有惋惜或者后悔，也不知道自己为什么这么执着。再看看窗外，天黑了，彻底睡着了。青黑色的万物安静，雨不疾不徐的下着，就静静地下着。既不惹人，也不袭人。不悲不喜。行于路上，尽管外面下着雨。八月晚上，考研备战 自习室中 雨]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活态度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斗破十年祭（之一）]]></title>
    <url>%2F2012%2F03%2F18%2F%E6%96%97%E7%A0%B41%2F</url>
    <content type="text"><![CDATA[看小说是一种境界！ 看完“武动”的最新章节后，突然想为自己的“小说生涯”做一个结束了。 自小喜欢书，不管是学校的教科书，还是从别人家捡来的，都视若珍宝的细读。那时，最喜欢的事便是抱着老姐的历史书一遍遍的啃啊！然后就在地理图册中细细的找，看完以后，还云里雾里地想象一番。什么千军万马厮杀原野，还是白衣将帅定鼎中原，抑或是风华雪月幽于孤岛。大漠飞雪、长河落日、小桥流水、孤舟飘荡。。。那些梦中才有的世界才出现在现在眼前。这些一直贯穿我的18年，虽然最后还是选择了理科，离那些曾经迷惘的东西越走越远。 在初二，在广州，在那个公园里，风落叶飘的小亭里，少年看着手中的《飘渺之旅》，静默的像一个雕塑。可内心却波涛汹涌，最喜欢那在原野上抵御兽潮的一节，天地昏暗，原野飞沙，在苍茫的天地间，万兽狂奔，刀血翻飞，最喜欢在那飘渺的雪山之巅，雪落若花，风舞白云，衣袂飘飘的玄女，横吹玉笛，惊落梅花。。。 暮然回首，现在读《飘渺之旅》，竟发现她有些幼稚。但曾经却给了自己心潮澎湃的理由。然后像其他人一样升入高中，在繁重的作业里，在宿舍里看了逆苍天的《大魔王》，在就过半天的星期日呆在教室里，在靠近窗户，在柔和阳光里看了洛水的《知北游》。我想每一本好小说都有自身独特的灵魂，虽然除去主角都很牛叉，老婆很多，都打不死，都会有坚毅的性格和英俊的外表的成分以外，他们都会给人带来为之疯狂的理由。事实证明创新是很重要的，不管是从人物性格，还是修炼形式，更或者是写作氛围，例如唐家三少，从最初的《生肖守护神》中的生肖之说，到《琴帝》中温婉善良的音竹，奇特的音波飞刃。再到《斗罗大陆》中痴情小舞、聪敏异常的唐三，武魂之说。然后《阴阳冕》、《天珠变》、《神印王座》无不都是创新。 记得曾经高三时，为了不让自己看小说，就把手机留在家里。每逢放假，什么肽肽键，什么椭圆双曲线，一坐上公车，这些全抛之脑后，全身心的急迫，完全式的投入，就算家里只有自己一人，就算蚊子漫天，也不管是在谁家蹭饭，从手接触到手机的那刻，自己就融入其中。 阳光高照、斜阳余辉、夜幕降临，亘古不变的姿势，直接冲着电的手机，凳子下燃着的蚊香，腿上满是红点，去看唐三的战斗而不惜憋着一泡尿的境界。不可谓不热血！不可谓不疯狂！ 读唐家三少，文笔朴实，背景广阔，情节流畅，质地夯实。人物性格坚毅聪敏，感情细腻，玲珑多变，平易近人，毫不突兀。爱唐三为爱至死不悔、为小舞矢志不渝的感情，爱他不畏艰险、心思缜密的坚毅表情，爱他在面对死亡透漏出的自信和平静。唐三写人当为一绝·，他写人情感细腻，他绝不仅仅局限于男女主角，他写人也不是性格如一，他善于描写不同人的不同性格，写兄弟，写伙伴，写敌人，写每一个平凡人。。。。例如写小舞的可爱，写戴淑白的邪眸和朱竹清的冷艳，写奥斯卡的搞笑和宁荣荣的任性。他写人，有时诙谐，有时悲壮，有时感伤，也正因为这样，人物的性格才更加的饱满，更加让人亲切。还记得那句奥斯卡大叔口头禅——老子有根大香肠，还有”坚挺，坚挺，金苍蝇“的绝技吗？ 唐三之才，让人叹服！ 总有一些情节可以让你感动落泪，总有些场景让你禁不住仰天长啸，心怀激荡。 我好像看见张，长满蓝银草的湖边，微风，细雨，小舞坐在唐三身边，脚轻轻地荡着，双手撑在坐下的圆木之上，扬起小脸，在星月之光的照耀之下更现娇俏，轻声对唐三说：哥，替我梳头。静静的让幸福溢满心怀，可谁又记得那株娇艳欲滴的”相思肠断红“滴满小舞的殷红鲜血呢？又有谁记得唐三强行剥下蓝银皇右腿骨让小舞逃走的的誓言，在面对两大斗罗时，在耗尽最后的生命力，就是为了甩出那段腿骨·，”小舞，用魂骨飞行技能，快走！“在喊出这句话时，紫黑色的血从嘴里狂涌而出。就为了一个永远守护你的誓言！而小舞双眼血红，她不能看着挚爱的人为他死去，她选择了燃烧，燃尽自己所有的生命，那刺眼的火焰好像是在见证爱的伟大。。。矢志不渝，至死不悔！**]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活态度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斗破十年祭（之二）]]></title>
    <url>%2F2012%2F03%2F18%2F%E6%96%97%E7%A0%B42%2F</url>
    <content type="text"><![CDATA[读小说更是一种心情！ 喜欢总有一种理由，看番茄《星辰变》、《吞噬星空》、《九鼎记》、《盘龙》，你会觉得故事很紧凑，从来不会生涩，看那些悲欢离合，看那些时空穿梭，看那些花开花落，总有站在云端山巅去看的感觉。他的气势不可谓不磅礴，他的感情不可谓不细腻，他的人物不可谓不形象，他是一个经验丰富的高手。他的节奏很鲜明，而不像辰东那样杂乱。辰东的《神墓》、《仙逆》跳跃性太强，思维多变，角度多变，充满灵动之感。对于我来言，我更喜欢《搜神记》，这是一本纯文人的大作，树下野狐造就了一个完全东方主义远古神话的世界，充满瑰丽的色彩，它拥有波澜壮阔的场景，也有优美如画的风景。纵然细细读来，仍然读不懂的只有那首《刹那芳华曲》。 朝露昙花，咫尺天涯，人道是黄河十曲，毕竟东流去。八千年玉老，一夜枯荣，问苍天此生何必，昨夜风吹处，落英听谁细数。九万里苍穹，御风弄影，谁人与共。千秋北斗，瑶宫寒若，不若神仙眷侣，百年江湖。 从搜神记到斗破，终觉得《斗破苍穹》不够好，不管是主角千篇一律的王霸之气，还是结尾处的草草落笔。。。 可斗破却让我为之等待，为之疯狂了从高中到大学。仍想起那为更新辗转反侧不能入睡的心情；还想起结束一天学习，躲在被窝到一两点的日子；还会想起课间休息时热烈疯狂地讨论。以至于我和鹏仔见面语总是：今天的更新，你看了吗？去吃饭的路上，吃饭的桌上，回宿舍的路上，全部是斗破。从回顾历史到展望未来，从技术层面到yy情节，从功法再到女主角，宛然可以算作另一次百家争鸣了。常常争到脸红脖子粗也在所不辞。往往是鹏仔那部诺基亚先进些，好多新章节，我们都是围在他才得知的。此情此景，让人神往！ 斗破大气！斗破雄壮！斗破往往有一种气势，藐视一切，焚天煮地，翻江倒海，碎山破空的气概！云岚宗一战动天下，炼丹场一丹定乾坤，焚炎谷一莲焚天地，太古岛一尺裂山河。斗破的大场面总让人心怀激荡，不能自已。它从人物的反应到功法的描述，从环境的渲染到气势的铺垫，都无与伦比！没有柔情，没有感动，也没有心情，一切都被气势所笼罩，一切都陷入云端，一切都忘乎所以。这边是风格，这就是大气！它会让你热血翻涌，让你处在无尽大漠之中，让你站在泰山之巅，让你立于波涛之中。气势可以战胜一切！ 斗破充满伏笔，层层铺垫，环环相扣。 斗破功法奇特，摇曳生姿，质感强烈。 斗破始终有一种雄浑之气，人物的出场总是雷霆万钧，景物的描写也尽是宏伟壮观，色彩全是荒凉的灰色和飘渺的白色。。。。 斗破有异火，有丹药。那吞噬一切的虚无吞焰，那狂暴猛烈的陨落心炎，那幽幽青莲地心火。还有拥有丹灵的奇特丹药，更有多姿多彩的药材，这些都是吸引人的所在。 似乎看到萧炎手握玄重尺，从云岚山的阶梯上缓缓出现，风狂吼，云翻涌，在铺满大理石的广场，横尺向天问，莫欺少年穷！ 似乎看到萧炎掌捧佛怒火莲，在无边的天地间驰骋纵横，马长嘶，血在飞，一句我命由我不由天！ 似乎看到萧炎指尖火焰，指向万兽鼎，翻腾江海间，一丹传千古！ 别了斗破，在今日，只想说，现实永远是真的，别了，那些梦里的日子，在此时，将你祭奠！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活态度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清晨]]></title>
    <url>%2F2011%2F09%2F30%2F%E6%B8%85%E6%99%A8%2F</url>
    <content type="text"><![CDATA[阳光爬满我的窗子…… 湮没在尘土里…… 脚步匆匆…… 晨风拂过我的脸颊…… 撞在石墙上…… 纷纷扬扬。 又是秋季…… 没有红叶，没有枯树…… 远行，在暮色里。 又是清晨…… 在雾气里，在阶梯上…… 读书，读一季秋。 四年之后，那个早晨…… 夏花开的绚烂…… 天空好蓝…。 当心中充满烟尘，成熟之藤紧紧缠绕… 是否还会有这个早晨… 这颗年轻的心…。 清晨遥遥… 像少年一样飞啦………… 2011-9-30 于中原工图书馆 有雾]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗与远方</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雪花烂漫…致某某]]></title>
    <url>%2F2011%2F09%2F30%2F%E9%9B%AA%E8%8A%B1%E7%83%82%E6%BC%AB%2F</url>
    <content type="text"><![CDATA[呵呵，好久没下雪了！ 要是真有个八月飞雪就好了…嘿嘿，我怨啊！你说你个小雪，总是打击我。当我终于臭美一次，你却说我再咋打扮就那样。当我终于认识一美女，你就说我没救了…此恨此情，犹如黄河之水淘淘不绝…咳，言归正传。说起小雪，此女冰雪聪颖，天生丽质…唉呀，说错了。 那个，在高四，你很瘦（好想你妈每天都在虐待你似的）。头发长长的，总疏着你招牌头型。一副眼镜。一句话，你很普通，就是一个小小的你…但，其实，你也很可爱，只是除了比我还笨。嘿嘿…好是说不出的，那就不说了…可，总是想起初次相见，你一拍，一吼，差点把我吓死。总是想起你打乒乓球的笨拙。总是想起在一起说你老弟时你的沧桑，好像你真的老了似的。一起走，一起说……咱俩性格类似，悲哀啊！情感化，迟钝形。你没有豪言壮语，却很踏实。你总是很认真，从不奢求童话，也从不报怨。你是一个小小的你…日子总要老去，影子描不出记忆…此刻，苍天白日之下，伴着青晨的薄薄凉气，我将记忆重温…想起我还欠的车费，明明说好的。想起同桌时我的小心翼翼。想起那次给你和胡曼带饭的争吵。呵呵，我欠你的粥钱什么时候还啊？风吹过，云飘过，总想在你的雨中为你撑一把伞……………… 一路顺风。27早记 2011-8-27 08:36 高四]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗与远方</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雪国]]></title>
    <url>%2F2011%2F09%2F30%2F%E9%9B%AA%E5%9B%BD%2F</url>
    <content type="text"><![CDATA[雪，飘在原野上。狂风呼啸，乱草茫茫。 游荡在雪的国度，落满冰碴的眉角，冷冻的血液仿佛冰下流动的暗流，脚踩在雪上嘎吱作响。远方有白茫茫的苍山，隔着冰冻的海，樱花飞舞，寒月皎洁，在飞舞的风雪中好像一群巨人，衣着冷色披风，追逐着远方的歌声，无所畏惧。 谁的歌声在飞扬，飘渺在无际的雪原，仿佛雪山顶上飞起的烽烟，一往无前，不知道何时消散。终于到了尽头，千万丈的雪瀑，被雪神钉死在冰崖上，无法移动。血液已经凝固，脸色也已苍白。忽的，万千雷电狂奔而下，泛着让死神也恐惧的寒光，从高处向崖底倾倒，光与冰的碰撞，在冰海上激起了冰浪，发出磔磔的闷响。在云与雪之中，有无数的冰霜巨龙，冰冷，毫无血色的蓝色眸子里，你就站在樱花树下，冰崖之上，纯白色的长发飞舞，遮住脸颊，冷艳而又凄美，雪色的披风上，雪之棱角点缀。雪狐在月色里也瑟瑟发抖，似乎也禁不住你那寒冷的目光。 银白色，雕着雪神之翼的手杖，引着雷光，轻轻地落在冰崖，寂静，死一般的寂静。冰之裂缝吱吱的向远方蔓延，像寒月全部化作雷电，向天地奔去。轰隆的巨响也慢慢清晰，雪狐也不安的躁动。来了，来了，暴风狂卷着冰粒，狂雪裹挟着山峰，无数的冰柱从原野上，刺破寒冰，穿过雪雾，喷薄而出，巨大的风暴声，后面跟着雪之巨人，挥舞着巨斧，骑着长着白色翅膀的骏马，从断裂的崖巅，呼啸而过，去讨伐那些雪之国度的叛徒。嚯嚯作响的斧敲冰声，撕裂的叫喊声，在雪龙喷出的雪团中显得是那么微不足道，烈烈的战旗，在风雪中飘扬。背叛就意味着死的祭奠，雪之祭奠，血之祭奠，远处又传来了那秃鹫兴奋地嘶叫，在雪里渐行渐远…… 又是谁的马铃声在轻吟，在雪的国度泠泠作响，在雪的渲染下也不在浪漫，慢慢的吟唱，冷冷的吟唱，浸入了你的皮肤，冰冻了你的心脏。要是在这片雪原上搭一个纯白的帐篷，架起一堆柴火，喝着猩红而又冰凉的红玛丽，吃着烤熟的熟牛肉，看着白烟袅袅升起，直直地向上，在半空又变成雪花飘下，落在你的肩膀上。我想那肯定是极唯美的。远处，也有猎狗在追逐雪兔，白绒绒的飞鸟慢慢的飘荡，跟着偶然被风吹乱的雪花，共舞在原野上。冰碴覆盖的林子里有嚯嚯的斧凿声，正在砍断树枝。苍白露出经络的枯草应风折断，感受着生命的荣枯，才发现呼呼的风声原来也是那么和蔼。暖和和冰冷，是多么矛盾的的感觉啊！可他们却彼此交融，那么放下战斧，唱一首挽歌，又有什么关系！ 2013/6/16 闷热，整个人也很烦，突然想起了冬天，想起了《林教头风雪山神庙》那段“雪下的更紧了！雪原上，林冲裹着披风，挑着枪，在雪地里踉跄前行，忽的，看到在大雪里的一间茅草酒肆，门前还挂着一杆酒旗。于是便推门而入，叫到“小二，一壶烧酒，二两熟牛肉”。也想到了郁达夫关于在老北京的炕上，围着火炉吃西瓜的惬意。不知怎么的就是特别向往那样的日子。还有冬天喝着冰啤吃火锅的小小梦想也没实现。也许这也就是矛盾的魅力吧！呆在宿舍，看别人玩Lol，也是看的热血狂涌的，于是便更加燥热了，又不想出去，但却热的受不了，所以胡写一点东西，用了好多关于冷的字词，想象一下冬天的寒冷，来给自己降降温！不过，真的感觉凉快了好多了啊！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活态度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行于路上]]></title>
    <url>%2F2011%2F08%2F31%2F%E8%A1%8C%E4%BA%8E%E8%B7%AF%E4%B8%8A1%2F</url>
    <content type="text"><![CDATA[行于路上！带些许留恋，也带一分憧憬。我离开这里，行于路上…窗外一帘青翠，在绿叶中隐约可见那些村子。极目远忘。，千里平原，一马平川，万亩良田。浩浩荡荡，雄阔异常。那呼啸而过的风，那交错而行的路，那阳光，那飞鸟…望着那苍天，意绪飞扬，路怎么弯，总回到达终点。天怎么蓝，总有暴风骤雨。可我们无法承受生命之轻，总想为记忆留下坎坷，所以我行于路上。明天谁可预知，命运无法安排。当赏高山之雄伟，便有欲与比高的胆气。当玩明月之皎洁，便有思乡怀人的幽情。此刻，目平原之辽阔，心中便涌动着感慨与激动。雄心壮志与幽远平淡共舞，青春热血与心中感慨齐飞。那当你失志潦倒时便看一看平原吧，这里可以给你希望和慰藉。因为我始终相信注定会有一段缥缈的音韵点染冗重的今生，所以我行于路上，一生追求……… 于邓州至郑州 第一次离开家乡上大学的途中 2011-8-31日 晴]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活态度</tag>
      </tags>
  </entry>
</search>
